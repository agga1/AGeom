""" prezentacja graficzna gotowych wynikow dzialania algorytmu grahama """
scenes = []

# dodanie zmodyfikowanych zbiorow z cw 1
setA = generatePoints(100, 100)
setB = generateOnCircle(100, 10)
setC = generateOnRect(1000,[-10, -10], [10, 10])
setD = generateOnSquare()
setE = generateOnRect(200, (10, 2), (14, 5))

sets = [setA, setB, setC, setD, setE]

for setx in sets:
    setGraham = graham(setx)
    scenes.append(Scene([PointsCollection(setx, color='blue'),
                     PointsCollection(setGraham, color='orange')])) 

plot = Plot(scenes)
plot.draw()


""" alg grahama """
from functools import cmp_to_key

def cmp (a, b, lowest=(0, 0)):  
    ans = orient(lowest, a, b)
    return -1*ans

def graham(points):
    lowest = findAndDelLowest(points)
    pts = sorted(points, key=cmp_to_key(lambda x,y: cmp(x, y,lowest)))  # sortowanie tablicy z wyłączeniem punktu najniższego
#     print(pts)
    points.append(lowest)  # ponowne dodanie najnizszego punktu do tabeli wejściowej
    i = 1
    res = [lowest, pts[0]]
    while i<len(pts):
        if len(res) < 2 or orient(res[-2], res[-1], pts[i]) > 0:
#             print("adding ", pts[i])
            res.append(pts[i])
            i += 1
        else:
#             print("removing ", res[-1])
            del res[-1]          
    return res



# mypts =[(1,2), (0,0), (2, 1),(0, -1) ,(-1, 1), (2, 3), (0, 3)] 
# print(graham(mypts))
# print(mypts)
    
""" orient """
def orient(a, b, c, eps=1e-12):
    matrix = [[a[0], a[1], 1], [b[0], b[1], 1], [c[0], c[1], 1]]
    det = 0
    for j in range(0, 3):
        det += matrix[0][j]*matrix[1][(j+1)%3]*matrix[2][(j+2)%3]
    for j in range(0, 3):
        det -= matrix[2][j]*matrix[1][(j+1)%3]*matrix[0][(j+2)%3]
    if det>eps:
        return 1
    elif det<-eps:
        return -1
    return 0
    

# def orient2(va, vb):
#     ca = (va[0], va[1])
#     cb = (vb[0], vb[1])
#     det = ca[0] * cb[1] - ca[1] * cb[0]
#     return det

# print(orient((1, 1),(3, 2),(5, 2)))

""" findLowest """
def cmpXY(a, b):
    if(a[1]<b[1]):
        return -1
    if(a[1]>b[1]):
        return 1
    if(a[0]<b[0]):
        return -1
    if(a[0]==b[0]):
        return 0
    return 1

def findAndDelLowest(points): # zwraca najnizszy wzgl y pkt (cmp y -> cmp x)
    if len(points) == 0:
#         print("no points")
        return None
    lowest = points[0]
    ind = 0
    for idx, point in enumerate(points):
        if cmpXY(point, lowest) == -1:
            lowest = point
            ind = idx
    del points[ind]
    return lowest

# ar = [(1,2), (-1,1), (0, 0), (1, 0), (0, 1)]
# print(findLowest(ar))
# print(ar)